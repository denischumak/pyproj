1)                           !Порты! 
Порты бывают двух видов: аналоговые и цифровые. На плате они выделены. Они оба могут выдавать и принимать цифровой сигнал, т.е 
последовательность 1 и 0, которые вырыжаются скачками напряжения 0В и 5В. Аналоговые порты могут еще и принимать аналоговый 
сигнал - напряжение. Ардуино измеряет его от 0 до 5 В с шагом 5 / 1024 В, т.е. примерно 5 милливольт.

                            !Датчики!
Бывают цифровые и аналоговые. Почти все имеют 3 провода, два из них - это плюс и минус (для подключения в цепь). Еще один провод
логический - нужен для передачи данных.


2)                          !Синтаксис!

// Однострочный комментарий

/* */ - многострочный

Функция setup() - все, что находится внутри нее, выполнятся только один раз при каждом запуске ардуино
Функция loop() - все, что находится внутри нее, будет бесконечно выполняться в течение работы ардуино.

!При объявлении переменной она автоматически инициализируется нулем!

Типы данных:
boolean (1 байт), значения 0 или 1
char (1 байт), значения -128 до 127
byte (1 байт), значения 0 до 255
int (2 байта), значения -32768 до 32767
unsigned int, word (2 байта), значения 0 до 65535
long (4 байта)
unsigned long (4 байта)
float, double (4 байта)
String

Реальная структура программы такая:
int main() {
    setup();
    while (true) {
        loop()
    }
    return 0;
}

Переменные, объявленные вне loop() и setup() - глобальные, те, которые
объявлены в setup() - недоступны в loop().

Выгодно использовать define.


3)                        !COM порт!
При подключении ардуино через COM порт прошивка начинает выполняться!
Используется для общения с ардуино.
Serial - объект библиотеки Serial для работы с COM портом.

В начале указывается скорость передачи данных через порт:
Serial.begin(<скорость>), по умолчанию 9600 бод.

Для вывода данных пишем:
Serial.print(<вывод>)
Serial.println(<вывод>)

Далее после загрузки этого кода в ардуино и при запуске, ардуино передаст
через COM порт информацию в Serial Monitor.

При выводе числа типа float можно указать кол-во знаков после запятой
для вывода:
Serial.print(3.141421421, 3)


Попробуем отправить данные на ардуино с компьютера:
Данные попадают в буфер размером 64 байта и ждут обработки.

Serial.available() - проверяет буфер на наличие входящих данных. 
Возвращает boolean.

Serial.read() - чтение данных из буфера. Считывает по байту и убирает
его из буффера. Возвращает число, не символ типа char.

Serial.flush() - ожидает окончания передачи исходящих данных.

Serial.parseInt() - при запуске функции запускается цикл, который ждет,
когда придут все цифры. Функция возвращает искомое число.


4) Функции времени

delay(<число миллисекунд>) - вызывает беск. цикл на заданное время.
максимальное значение - максимум unsigned long.

delayMicrosecond(<число микросекунд>)

millis() - кол-во миллисекунд, прошедших с момента включения контроллера.
максимальное значение - максимум unsigned long. Шаг 1 миллисекунда.

micros() - то же, но в микросекундах. Максимум тот же, разрешение - 4 мкс.


5) Цифровые порты

Цифровые порты могут выдавать ШИМ сигнал (то есть цифровой сигнал, 
который очень быстро обновляется). Таким сигналом можно регулировать 
яркость лампочек и скорость моторчиков, степень нагрева и так далее.

Аналоговые порты могут работать как входы, так и выходы.
По умолчанию порты настроены как входы.

pinMode(pin, mode) - настройка порта. Цифровые: 0-13, аналоговые: 14-19,
либо A0-A5. Режимы работы: INPUT, OUTPUT (выдает 0 или 5 вольт), 
INPUT_PULLUP (ДАЛЕЕ).

digitalWrite(pin, signal) - подать цифровой сигнал. signal бывает:
LOW (false, 0) - 0 вольт, HIGH(true, 1) - 5 вольт. 

Светодиод on подключен к пину 13, если подать на него низкий сигнал - 
он погаснет.

digitalRead(pin) - прочитать цифровой сигнал с пина. Если к пину не
подведено напряжение, то по умолчанию там 0.

Режим INPUT_PULLUP соединяет пин 5В с указанным пином через резистор
сопротивлением 10 кОм.
Я расчитал, что добавочное сопротивление должно быть 250 Ом или больше,
чтобы на пин приходило не более 20 мА (рекомендуемый максимум).

6) Обработка нажатия кнопки при помощи флажков

#define MS_WAIT 50
boolean butt_flag = false; 
boolean butt;
boolean led_flag = false;
unsigned long last_press;

void setup() {
  pinMode(8, INPUT_PULLUP);
  pinMode(13, OUTPUT);
  digitalWrite(13, LOW);
  Serial.begin(9600);
}

void loop() {
  butt = !digitalRead(8);
  if (butt && !butt_flag && millis() - last_press > MS_WAIT) {
    butt_flag = true;
    Serial.println("key is pressed");
    led_flag = !led_flag;
    digitalWrite(13, led_flag);
    last_press = millis(); // защита от дребезга контактов кнопки
  }
  if (!butt && butt_flag) {
    butt_flag = false;
    Serial.println("key is unpressed");
  }
}

Для кнопок можно использовать библиотеку OneButton:
https://github.com/mathertel/OneButton




8) Реле

Можно взять лампочку, подключенную к 220В через розетку. Один провод (+)
разрезать и подключить в реле. 
Реле при подаче сигнала размыкает или смыкает цепь. То есть вместо 
механической кнопки управление происходит током.
Реле бывает электромагнитным и твердотельным. электромагнитное по сути
механическое, оно хуже чем твердотельное, которое сделано на полупроводниках.

Чтобы изменить свое состояние реле нужен ток, а тока с логического пина
ему для этого не хватает. Поэтому ему нужно дополнительное питание,
что сказывается на электропотреблении.

В реле есть 3 порта:
1. COM (common) - сюда втыкается провод всегда. Через этот порт течет ток.

2. NO (normally open) - при отсутствии высокого сигнала на логическом
порте реле через сюда не проходит ток. То есть в отсутствии сигнала порт
COM c NO не соединен. Когда напряжение подается, они соединяются.

3. NC (normally closed) - в отсутствии сигнала на логическом порту соединен
с портом COM.


9) Транзисторы
TBD


10) Потенциометры и аналоговые пины
На аналоговых пинах возможно измерять напряжение. Этим занимается 
аналогово-цифровой преобразователь (АЦП). Он преобразует напряжение на
аналоговом пине в число. Разрядность АЦП - 10 бит, т.е он может выдавать
всего 1024 различных значения: от 0 до 1023.

В итоге при 0В получаем 0, при 5В получаем 1023.

Потенциометр - устройство, которое позволяет изменять напряжение (потенциал)
на своем центральном пине. Остальные два - 5В и 0В. Когда мы крутим
переключатель, изменяется сопротивление.

analogRead(pin) - возвращает значение 0..1023 в зависимости от напряжения
на пине.

map(value, min, max, new_min, new_max) - конвертация значения value В
новый диапазон.
min, max - диапазон значения value
new_min, new_max - новый диапазон значения


11) ШИМ сигнал
Ардуино умеет выдавать ШИМ сигнал.
analogWrite(pin, duty) - выдать ШИМ сигнал на pin. duty - значение от
0..255, чем оно выше, тем больше среднее напряжение сигнала,
т.е тем больше скважность. Шаг такого управления примерно 0.02В (5 / 255)

Функция analogWrite работает ТОЛЬКО на пинах: 3, 5, 6, 9, 10, 11

12) Случайные числа
random(min, max) - случайное число в диапазоне от min до max - 1
random(max) - случайное число от 0 до max - 1

13) Аппаратные прерывания
На ардуино уно есть только 2 пина, которые поддерживают аппаратные 
прерывания: D2, D3
Суть их в том, что независимо от точки исполнения кода ардуино опрашивает
эти 2 пина постоянно. То есть если сейчас ведутся расчеты в коде,
то этот пин все равно будет опрашиваться. Таким образом он работает
параллельно со всем кодом.

Скорость чтения при прерывании составляет несколько микросекунд, что очень
быстро.

attachInterrupt(pin, function, mode) - подключить прерывание.
detachInterrupt(pin) - отключить прерывание.
Здесь:
pin - начинается с нуля и не совпадает с номерами пинов. Здесь 0 означает
D2, 1 - D3.
function - вызываемая функция, можно создать, например, самому.
mode - режим работы, бывает:
LOW - прерывание срабатывает, когда на пине сигнал LOW. 
RISING - срабатывает, когда сигнал меняется с LOW на HIGH.
FALLING - срабатывает, когда сигнал меняется с HIGH на LOW.
CHANGE - когда сигнал просто меняется.

noInterrupts() - приостановить обработку прерываний.
interrupts() - продолжить обработку.


!!!Если внутри функции function изменяется глобальная переменная,
то она должна быть объявлена с модификатором volatile.
Функция millis() не меняет своего значения за время работы этой функции,
delay() внутри не работает.
