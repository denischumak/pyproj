Все сущности - объекты, любые строки - экземпляр класса str, число 1514 -
экземпляр класса int

input("строка") - пользователь увидит "строка" в терминале, а дальше должен
будет что то ввести и нажать enter. Всегда возвращает значение типа str

dir(переменная_какого-то_типа) - все названия атрибутов объекта, dir() - 
выводит созданные переменные в области видимости

id(переменная) - уникальный идентификатор объекта, его адрес в памяти

Неизменяемые:
str, bool, int, float, NoneType

Изменяемые:
list, dict, set, user-defined classes

Переменные и объекты:
Переменная ссылается на объекты. Код: a = 10, b = 10 работает так, что
создается лишь один объект 10, и a, b ссылаются на один и тот же объект

type() - тип объекта, его класс



////////////////////////// СТРОКИ /////////////////////////////
Многострочная строка: """abcabcabcabc"""
len(str) - возвращает длину строки
str[0] - нулевой элемент строки, str[3: 6], подстрока, которая не
включает 6 эленемент. str = 'DenisDenis', str[3:6] = 'isD'
Можно писать: str[:], str[3: ], str[:3]
str.replace(old_str, new_str, count) - замена old_str на new_str, 
причем замена всех вхождений old_str, если count = -1, иначе не больше чем
count вхождений, начиная с начала строки.
str.count() - кол-во вхождений подстроки
str[-1] - последний элемент строки, str[-2] предпоследний и тд

Оператор+ для строк это конкатенация строк.



////////////////////////INT - ЦЕЛЫЕ ЧИСЛА/////////////////////
int(object) - функция, преобразует к типу int 
pow(base, power), base**power - возвездение base в степень power 
Длинные числа можно писать так: 1_000_000


/////////////////////////FLOAT///////////////////
float(object) - конвертация
round() - округление к ближайшему целому



/////////////////////COMPLEX/////////////////
x = 3 + 5j
Принадлежат классу complex


/////////////////BOOL////////////////////////
Значения пишутся с большой буквы: True, False
bool(obejct) - конвертация
bool([]) = False, bool(None) = False
Сравнение строк посимвольное, 'Long' > 'long'




//////////////////////КОНВЕРТАЦИЯ ТИПОВ////////////////////////
Еще конвертации: list(), tuple(), set()
Неявной конвертации int, float к str нету. Т.е '10' + 5 - нельзя.
float + int можно, bool + int тоже
 При сложении int + float вызывается метод __radd__, определенный в классе
 float, при этом неявной конвертации не происходит!



 ///////////////////МАГИЧЕСКИЕ МЕТОДЫ////////////////////////////
 __add__(), __eq__() и т.д.
 help(list.__eq__) - так можно получать информацию о магических методах



 /////////////////////СПИСКИ///////////////////////////

Список может содержать элементы произвольного типа. Элементы пишутся в 
[] скобках. Изменяемый объект. В списках важен порядок следования
элементов. Реализация через динамический массив.
len(list) - длина списка
list[0], list[-1], list[1:3] и т.д как со строками можно делать
list[0] = 5 - можно изменять значения, так как объект изменяемый

 !!! За оператор [] отвечает метод __getitem__() !!!

Для удаления элемента по индексу: del list_variable[index]
Возможно делать так:
a = 'apple' 
b = 'banana'
c = [a, b]

Методы списков:

list.append() - аналог push_back(), добавление в конец
list.pop() - удаление последнего элемента, аргумент по умолчанию = -1
list.pop(index) - удаление по индексу
Метод pop() возвращает удаленное значение

list.sort() - сортировка по возрастанию
list.sort(reverse=True) -  сортировка по убыванию

list(str_variable) -  разбивает строку по буквам на список
list(dict_variable) - получаем список ключей словаря
min(list_variable), max(list_variable), sum(list_variable)

Оператор + для списков конкатенирует их. [1, 1] + [2, 2] = [1, 1, 2, 2]

Код:
first = ['Denis', 'Margo']
second = first
second.append('x')
Получаем, что first теперь тоже изменился

Копировать список можно так: list[:], list.copy(), list(list_variable)

list.count(element) - сколько раз встречается элемент count
list.insert(index, object) - вставляет объект перед индексом
list.clear() - очистка списка
list.extend(object) - к списку добавляется другой объект, который 
разбивается на список. Объект должен быть итерируемым

При создании списков кодом:
a = [1, 2, 3]
b = [1, 2, 3]
Будут создаваться разные объекты, в отличии от создания объектов типа
int или float. Кажется, для неизменяемых объектов создается только 
один объект, для изменяемых - разные. Это и логично.

list.reverse() - изменение порядка следования на обратный
Тип не хешируемый, т.е ключом словаря, например, быть не может



//////////////////////////////СЛОВАРИ////////////////////////
Значением может быть объект любого типа данных. Ключ - хешируемый объект.
Создается в {}, my_dict = {1414: 'deniska', 'rock': True}. Изменяемый.
Порядок значения не имеет, можно убедиться, используя оператор равно.
У элементов нет индекса. Словари реализованы через хеш-таблицы.


К ключам можно обращаться по имени ключей: 
my_dict['rock']
my_dict[1414] = 177 - изменение объекта

variable = 'rock'
my_dict[variable] = 5 - можно обращаться через переменную. Очевидно, ибо
туда просто передается объект типа str или другого.

Добавление элементов:
my_dict['hello'] = False
Если ключ 'hello' есть в словаре, ключ будет изменен.

Удаление: del my_dict['key']

Создавать словари можно и так:
var = 15
lst = {'age': var, 'other': [12321, 231]}

При этом значение var копируется, а не ссылается.
Тоесть код var = ['abra', 12] не изменяет словарь
len(my_dict) - длина словаря
my_dict.get('key') - получить значение ключа. Если такого ключа нет, 
вернет None
my_dict.get('key', value) - вернет value, если ключа 'key' нет в словаре

my_dict.keys() -  объекта типа dict_keys, который содержит ключи. Можно 
конвертировать в list используя list(my_dict.keys())

dict умеет так: dict([['first', 15], ['second', 10]]) - сможет
преобразовать корректно в словарь. Если написать dict(['a', True]) - то 
не получится. Будет ошибка.

Словари можно объединять оператором |:
res = first_dict | sec_dict
Порядок следования важен. Доступно начиная с версии 3.9.0

Удобно делать такой перебор словаря:
for item in dict.items():
    key, value = item
    print(key, value)
Причем здесь item - кортеж, поэтому очевидная его распаковка происходит.

Можно писать и так:
for key, value in dict.items():
    print(key, value)

///////////////////////КОРТЕЖ TUPLE/////////////////////////
Неизменяемые объекты, в отличие от списков. Создаются в () скобках.
Порядок элементов важен. Через [] можно получать значения элементов, 
как и в списках. Только теперь нельзя: tuple[0] = 5, del tuple[0] - тоже.
При этом можно делать так:
var = ({"id": 1, "adw": 15}, {"other": 12, "noone": "str"})
var[0]["id"] = 5 - мы изменяем изменяемый элемент, но не кортеж

Можно делать так, как и ранее:
a = 5
b = 10
tup = (a, b)

Объединение кортежей: tup_1 + tup_2 - через оператор +

tuple.count(element) - сколько раз встречается element
tuple.index(element) - индекс первого встреченного element

Можно конвертировать в список: list(my_tuple)
Из списка в tuple тоже можно.







//////////////////////////МНОЖЕСТВА SET//////////////////////////
Неупорядоченная последовательность. Содержит только уникальные элементы.
Изменяемый тип данных. Создается через {}.
В наборы нельзя добавлять элементы типа list, dict, set. Элементы должны
быть хешируемы, а вообще говоря нельзя добавлять изменяемые объекты, 
поскольку у них при изменении нужно пересчитывать хеш и нужно удалять
дубликаты. Это не то, как должна работать такая структура данных.
Очевидно, del так же не работатет. Set реализован через хеш-таблицу.

Для создания пустого набора используется функция set().

set.add(element) - добавление element в множество
set.union(other_set) - объединение множеств, можно использовать оператор |
set.intersection(other_set) - пересечение, можно использовать оператор &

Методы union и intersection возвращают новое множество
set.issubset(other_set) - находится ли set в other_set
set.issuperset(other_set) - содержит ли set множество other_set
set.discard(element) - удаление element, если element нет в наборе,
то ошибки не будет.
set.remove(element) - тоже удаление, но выдаст ошибку, если нет элемента
set.difference(other_set) - разность множеств
set.symmetric_difference(other_set) - симметрическая разность






//////////////////////ДИАПОЗОНЫ RANGE/////////////////////

Диапозон - неизменямая последовательность элементов. Порядок важен, 
значит есть и индексы элементов.

Создать объект range можно так:
range_obj = range(7)

Диапозон - итерируемый объект, можно сделать:
list(range(4)) = [0, 1, 2, 3]

Общий синтаксис: range(start, stop, step). Если step < 0, то 
start >= stop, иначе start <= stop

my_range[index] - возвращает элемент диапозона.
Но my_range[1:3] - снова возвращает диапозон, но который содержит
указанные элементы.



///////////////////////////Функция ZIP////////////////////////////

fruits = ['apple', 'lime', 'banana']
prices = [10, 75, 15]
union = zip(fruits, prices)
print(list(union)): [('apple', 10), ('lime', 75), ('banana', 15)]
Можно передать больше списков (или просто итерируемых объектов)
Объект формируется на основании самого короткого из переданных списков.
Созданный объекь принадлежит классу zip. После конвертации в list, 
внутренние элементы будут кортежами. Можно конвертировать в dict, 
только если передать 2 аргумента в zip. Ключи - первый переданный объект.



///////////////////////ИЗМЕНЕНИЕ ОБЪЕКТОВ///////////////////////

Код:
num1 = 10
num2 = 10
num1, num2 буду ссылаться на один и тот же объект 10. Так будет 
происходить, если объект неизменяемый. Если изменяемый, то будут созданы
разные объекты. Это возможно, кстати, потому что неизменяемые объекты
хешируемы, а поэтому можно и быстро делать перебор на совпадение.
Оператор= копирует лишь ссылку на объект, поэтому надо следить за 
копиями. По сути глубокого копирования тут по умолчанию нет, в отличии от
cpp.

Если значения ключей - изменяемые объекты, то копирование ключей не 
выполняется. То есть при использовании метода copy(), например, для
словаря: {'apple': [15, 16], 'lime': 75, 'banana': 15} будет создан
новый словарь, в котором [15, 16] - тот же самый объект.
Поэтому dict['apple'].append(17) повлияет на изначальный объект.

КАРОЧЕ: метод copy() для list, dict, set и т.д. не создает копий
самих элементов. Сами элементы списка остаются с тем же id и те же самые.

Для создания полных копий нужно использовать модуль:
from copy import deepcopy
deepcopy(object) - его глубокая копия



///////////////////////////////ФУНКЦИИ/////////////////////////////

Функция - это объект, экзмепляр класса function. Параметры передаются
по ссылке. Если нету слова return, то есть функция типа void, она будет
возвращать значение None.

Если внутри функции пока нету кода, можно использовать слово pass, 
чтобы код запускался.
def foo(): 
    pass
Получили корректный блок кода. pass можно использовать там, где нужна
хотя бы одна строчка кода. В том числе в цикле.


Переменые, которые указаны после имени функции - параметры, которые
используются при вызове функци - аргументы.

def sum(*args):
    pass
*args - объединение всех позиционных аргументов в кортеж. То есть в эту
функцию можно передавать любое кол-во аргументов любого типа, они будут
объединены в кортеж. Можно использовать слово, отличное от args, например
aaarg, но принято args.

При передаче позиционных агрументов в функцию порядок их передачи важен.
Есть так же аргументы с ключевыми словами (keyword arguments, именованные)
Вместо кода с позиционными аргументами:
def sum(a, b):
    pass
print(sum(5, 6))


Можно использовать keyword аргументы:
def sum(a, b):
    pass
print(sum(a=5, b=6))

Суть в том, что порядок написания аргументов теперь не важен. Код теперь
читабельнее, так что предпочтительнее keyword arguments.

Позиционные и именованные аргументы можно использовать вместе.
def sum(a, b):
    pass
print(sum(5, b=6))



Можно объединять именованные аргументы в словарь:
def info(**kwargs):
    print(kwargs)
info(name='Denis', age=20, country='Russia')

Будет выведено: {'name': 'Denis', 'age': 20, 'country': 'Russia'}

Если передать такие аргументы: 
info('Denis', age=20, country='Russia')
То будет ошибка, поскольку **kwargs используются только для именованных
переменных, не для позиционных.

Можно передавать и позиционные, и именованные аргументы, для этого:
def info(*args, **kwargs):
    pass
Сначала передаются позиционные аргументы, потом именованные. Перемешивать
их передачу нельзя. Порядок параметров менять тоже нельзя.



//////////////////////////Колбэк функции//////////////////////////
Аргументом функции может быть другая функция.

def foo():
    print('foo')

def callto(func):
    func() - и есть колбек функция.

callto(foo)


//////////////////////Описание функций////////////////////////////
Описание можно добавлять так:
def func(a, b):
    """Это описание функции func"""
    pass


///////////////////////ОБЛАСТИ ВИДИМОСТИ///////////////////////

В пайтоне допускаются объявления функций внутри других функций:
def func1(a, b):
    def func2(c, d):
        a = 1
        b = 12
        print(a, b)

    func2(a, b)

func1(5, 6)

При этом переменные a и b, которые объявляются в функции func1, будут
так же доступны в func2. То есть область видимости func2 включает func1,
а еще глобальные переменные. При этом переменные c и d в func1, очевидно, 
не видны.

В итоге получаем, что пайтон сначала ищет переменные a и b внутри
функции func2, потом внутри func1 (более широкой области видимости), 
а потом в глобальной области.

В пайтоне есть только 2 области видимости: глобальная и область видимости
функции. То есть переменные, созданные внутри if или цикла for будут
созданы либо в глобальной области, либо внутри функции. 


Внутри области видимости функции нельзя изменять глобальную переменную.
a = 10
def add():
    a = a + 5
    print(a)

add()
Такой код работать не будет. Суть в том, что пайтон попытается создать
локальную переменную a, но при этом нам нужно вычислить a + 5, где 
a - только что созданная локальная перемнная без присвоенного значения.
В итоге получаем ошибку. Чтобы ее исправить, нужно написать так:
a = 10
def add():
    global a
    a = a + 5
    print(a)

add()
В результате мы говорим, что переменную a считать глобальной, 
не надо создавать локальной. С помощью global можно создавать глобальные
переменные внутри функции:

def add():
    global a
    a = 10 - создалась глобальная переменная a



//////////////////////////////ОПЕРАТОРЫ////////////////////////

Оператор is: определяет, одинаковые ли объекты, т.е равны ли их id
Оператор not: аналог ! в C++
Оператор and: аналог && в C++
Оператор or: аналог || в C++
Побитовые операторы такие же, как в C++
Оператор in: проверяет, есть ли элемент в последовательности. В случае
использования со словаря возвращает, есть ли КЛЮЧ в словаре.

and и or - ЛЕНИВО ВЫЧИСЛЯЮТСЯ




/////////////////////////ЛОЖНЫЕ ЗНАЧЕНИЕ////////////////////
значение является ложным, если при преобразовании его к типу bool
мы получим False. Список таких значений:
{}, (), [], set(), range(0), "", 0, 0.0, 0j, None, False
Все пустые последовательности - ложные значения.


////////////////////////ОПЕРАТОР РАСПАКОВКИ СЛОВАРЯ///////////////////
Посмотрим на такой код:
button = {
    'width': 200, 
    'text': 'Buy'
    'color': 'green'
}

red_button = {
    **button, - распоковали ключи и добавили их в новый словарь
    'color': 'red'
}
В таком случае в red_button ключ 'color' перезапишется на 'red'.



button = {
    'width': 200, 
    'text': 'Buy'
    'color': 'green'
}

red_button = {
    'color': 'red',
    **button
}
А в этом случае 'color' станет 'green'.
То есть порядок распаковки важен.



С помощью ** можно объединять словари:
result = {
    **button,
    **red_button
}



//////////////////////////ФОРМАТИРОВАНИЕ СТРОК//////////////////////

В пайтоне есть f-strings. 
В начале ставится символ f, после идут "". Внутри можно использовать 
{}, внутри которых могут быть переменные, числа, вызовы функций и тд.

print(f"{15} + {1.1} = {15 + 1.1}")



/////////////////////////ЛЯМБДА ФУНКЦИИ///////////////////////////

Cинтаксис лямбда-функции: lambda param1, param2, ... : expression
В качестве expression допускается одно выражение. return писать не надо.
Пример: lambda a, b: a * b

Лямбда функция - объект класса function, его можно присвоить переменной.
А дальше можно вызывать, используя имя переменной и ().

Т.е:
x = lambda a, b: a * b
print(x(5, 6)) # будет 30



///////////////////////ОБРАБОТКА ОШИБОК////////////////////////

Синатксис:

try:
    # Блок кода
except ErrorType:
    # Выполняем в случае ошибок

ErrorType - тип возникшей ошибки.




Пример:
try:
    print(10 / 0)
except ZeroDivisionError:
    print("exception occured")

Чтобы ловить все возможные ошибки, нужно писать вместо ErrorType
Exception либо вообще ничего не писать.

Можно делать так:

try:
    print(10 / 0)
except Exception as e: - полиморфизм
    print(e) # division by zero

try:
    print(10 / 0)
except:
    print('error occured')


Так можно автоматически выводить информацию об ошибке. Надо заметить,
что функция print пытается вывести текстовую версию объекта, то есть
она пытается вызвать метод __str__(), и если его нет, делает что-то дальшМожно обрабатывать много разных ошибок в разных блоках except.е.

Можно обрабатывать много разных ошибок в разных блоках except.

Есть еще блок else: - он выполняется, если ошибок не возникло. Есть блок
finally - выполняется в любом случае.


Можно создавать ошибки. Используется ключевое слово raise (аналог throw)



///////////////////////////РАСПАКОВКА/////////////////////////////
Распаковка - извлечение значений и присвоение их переменным. 
Распаковка списков:
lst = [5, 6, 7]
a, b, c = lst
print(a, b, c) # 5 6 7
Распаковка кортежей та же самая.

Можно писать и так:
lst = [5, 6, 7]
res, *left = lst
print(res, left) # 5 [6, 7]


Оператор ** можно использовать для распаковки словаря в аргументы
с ключевыми словами: 

dct = {
    'f': 1,
    's': 2
}

def foo(f, s):
    print(f, s)

foo(**dct)


Аналогично можно использовать * для распоковки списка в позиционные 
аргументы.

Эти операторы можно использовать для распаковки в значения.
То есть *[1, 2, 3] вернет 1,2,3 как отдельные значения, которые можно
будет использовать. Аналогично и для словарей.



//////////////////УСЛОВНЫЕ ИНСТРУКЦИИ И ЦИКЛЫ///////////////////

В пайтоне вместо else if используется elif.
Тернарный оператор: Выражение_1 if Условие else Выражение_2. В случае
истинности Условие выполняется блок Выражение_1


Циклы используются для перебора последовательностей. Бывает 2 типа:
for element in object и while. Если мы хотим сделать лишь определенное
количество действий, можно писать:

for _ in range(1000):
    pass
Здесь _ это анонимная переменная.





////////////////////////функция enumerate()/////////////////////////
Пусть a = [55, 17, 'str'] - список. 
Функция enumerate(a) возвращает объект типа enumerate, по которому можно
итерироваться. Каждый элемент этого объекта - кортеж, где на первом месте
стоит индекс элемента в списке, а на втором - сам элемент.

for element in enumerate(a):
    print(element) # (0, 55), (1, 17), (2, 'str')

По умолчанию порядковые номера расставляются с 0, но это можно изменить:
enumerate(a, 15) - теперь начнет проставлять номера начиная с 15.

 





///////////////////////ГЕНЕРАТОРЫ СПИСКОВ///////////////////
Общий синтакис у генераторов списков такой:
[выражение for значение in объект if условие_истинно]. Добавление if
гарантирует выполнение блока выражение, если условие_истинно = true.
Это опционально, можно писать и так:
[выражение for значение in объект]

Можно использовать двойные циклы:
a = [(j, i) for i in 'ab' for j in range(2)]
Получим: [(0, 'a'), (1, 'a'), (0, 'b'), (1, 'b')]

То есть это вложенный цикл. Можно хоть сколько for сюда засунуть.





/////////////////////// ГЕНЕРАТОРЫ И ИТЕРАТОРЫ ///////////////////

Выражения-генераторы создаются так:
a = (выражение for значение in объект if условие_истинно)
То есть отличается от генераторов списка это скобками. Обьект а -
экземпляр класса generator.

Генератор - итератор, элементы которого можно обойти только один раз.

Итератор - объект, который поддерживает функцию next(). Итератор помнит,
какой объект будет следующим. То есть используя функцию next(), каждый
раз состояние такого объекта меняется.

Итерируемый обеъект - объект, элементы которого можно поочередно обойти.
Может быть преобразован к итератору. 

Для преобразования к итератору используется функция iter().
a = iter([5, 1, 2, 10])

Элементы генератора не хранятся все в памяти. Они хранятся по одному
при выхове функции next().

Это полезно, когда мы делаем так:
c = (i for i in range(1_000_000_000_000_000))
for i in c:
    print(i)
Если создавать c как список, то получим переполнение.


////////////////// ФУНКЦИЯ ГЕНЕРАТОР И СЛОВО yield//////////////////
Используется ключевое слово yield.
Пример:

def genf():
    s = 7
    for i in [43, 65, 32]:
        yield i
        print(s)
        s = s * 10 + 7

g = genf()
print(next(g))
print(next(g))

При вызове функции genf() нам возвращается генератор.

Далее при вызове next(g) код выполняется до ключевого слова yield,
возвращается 43 и функция замораживается.
При следующем вызове мы начинаем со следующей строчки кода, то есть
выводится значение 7, и s = 77, доходим снова до yield 65 
и останавливаемся

Далее аналогично.

Можно выводить последовательность факториалов, не храня все в памяти:
def fact_seq(n):
    if not isinstance(n, int):
        raise TypeError("n type must be int")
    if n < 0:
        raise ValueError("n must be greater or equal to zero.")
    mult = 1
    for i in range(1, n + 1):
        mult *= i
        yield mult


x = fact_seq(10)

for el in x:
    print(el)



/////////////////////// ЗАМЫКАНИЯ ///////////////////////

Пример:

def main_func(value):
    name = value
    def inner_func():
        print(f"hello {name}")

    return inner_func

b = main_func('Denis')
b() # hello Denis

Связь inner_func() со значением name и есть замыкание. inner_func - 
функция, в локальной области которой нету name, но она знает про нее.
При вызове main_func('Denis') переменная name сохраняется, и ее можно
использовать.

Можно написать так:

def main_func(name):
    def inner_func():
        print(f"hello {name}")

    return inner_func

b = main_func('Denis')
b() # hello Denis


Пример функции, которая считает количество ее вызовов:
def counter():
    count = 0

    def foo():
        nonlocal count
        count += 1
        return count

    return foo

res = counter()
for i in range(10):
    print(res())



////////////////////////// ДЕКОРАТОРЫ //////////////////////

Декораторы нужны для расширения функционала существующих функций.
Декоратор - функция, которая принимает в качестве аргумента принимает
другую функцию и возвращает тоже функцию.

Пример декоратора, написанного своими руками:

def decator(func): # функция - декоратор
    def inner():
        print("start") # расширяем функционал функции func
        func()
        print("end") # тут тоже расширяем

    return inner

def say():
    print("hello world")

say = decator(say)

Теперь при вызове say будет вызываться функция inner, которая как раз
расширяет функционал функции say.

Еще пример:

def decator(func):
    def inner(name):
        print("start") # расширяем функционал функции func
        func(name)
        print("end") # тут тоже расширяем

    return inner

def say(name):
    print('hello', name)

say = decator(say)
say('Denis')

Если я захочу добавить новые аргументы у функции say, мне придется
менять код внутри decator, и чтобы избежать изменений кода в двух местах
можно писать так:

def decator(func):
    def inner(*args, **kwargs):
        print("start")
        func(*args, **kwargs)
        print("end")

    return inner


def say(name, surname):
    print("hello", name, surname)


say = decator(say)
say("Denis", 'Chumak')


Теперь применим специальный синтаксис и навесим декоратор:

@decator
def say(name, surname):
    print("hello", name, surname)


Теперь при вызове say("Denis", 'Chumak') вызывается функция inner так,
будто бы мы сначала сделали say = decator(say)

Можно и несколько декораторов навешивать. 

После декорирования функции пропадает ее изначальное имя и документация.
Поэтому можно исправить это так:
def decator(func):
    def inner(name):
        print("start") # расширяем функционал функции func
        func(name)
        print("end") # тут тоже расширяем

    inner.__doc__ = func.__doc__
    inner.__name__ = func.__name__
    return inner



///////////////////////// ИНТЕРПРЕТАТОР //////////////////////

В питоне есть компилятор, который проверяет код на синтаксические ошибки.
Далее он преобразует код в байт-код и отправляет на виртуальную машину,
которая выполняет код. То есть на самом деле питон не выполняет все
построчно.


/////////////////////// assert ////////////////////////////

assert _выражение_, _сообщение_.
Если _выражение_ истинно, продолжаем выполнять код. Если ложно, кидается ошибка, в которой будет _сообщение_.

//////////////////////////////////////////////////////////////////
/////////////////////////ООП////////////////////////////////////
//////////////////////////////////////////////////////////////////




//////////////////////////// МОДУЛИ //////////////////////////

Модуль - любая программа на питоне. У модуля есть атрибуты - пространство
имен и расположение на компьютере. В питоне есть стандартная библиотека,
она ставится с питоном по умолчанию.
Синтаксис импорта: import имя_модуля as псевдоним_модуля

Для импорта определенных имен пишут: 
from имя_модуля import переменные, функции и тд.
При таком синтаксисе происходит подключение имен в навешивать
собственное пространство имен, а не через модуль.
from math import * - импорт всех имен в собственное простраство имен.


Собственные модули можно импортировать так же, нужно просто писать
import имя_файла

Если импортируемуый модуль лежит в другой папке, нужно писать
имя_папки.имя_импортируемого_файла

После импорта питон проходит по импортируемому файлу и выполняет команды,
то есть присваивания, например. Каждый модуль импортируется только один
раз.
Чтобы импортировать второй раз модуль, нужно сделать так:
import importlib
# тут импортируем модуль имя_модуля
importlib.reload(имя_модуля) # делаем повторный импорт


У модуля есть магическая перемнная __name__. Если мы запускаем модуль
напрямую, то __name__ == __main__, а если мы импортируем модуль,
то, как известно, во время импорта код модуля выполнится, и его имя
будет являться именем модуля, а не __main__.

Поэтому если мы хотим, чтобы код модуля выполнялся только тогда,
когда мы запускаем его напрямую, можно писать:

if __name__ == '__main__':
    pass #пишем тут код, при импорте этого модуля он не выполнится.



Пакеты - папка с модулями. Если добавить в пакет файл __init__,
то он будет импортироваться (выполняться) в любом случае, даже без
его явного импорта.

########################### АТРИБУТЫ КЛАССА #########################
Пример простого класса:

class Person:
    name = 'Ivan'
    age = 30

К атрибутам класса можно обращаться без создания экземпляров через точку.
Например, Person.name

Для вывода всех атрибутов класса можно использовать Person.__dict__
Для получения значений атрибутов можно писать: 
getattr(Claass_name, 'attrubute_name', значение_если_аттрибута_нет)
Например: 
getattr(Person, 'name') # Получим 'Ivan'
getattr(Person, 'x', 100) # Получим 100

Чтобы изменить атрибут пишем: 
Person.name = 'Denis'

Так можно и создать новый атрибут:
Person.x = 120 

Можно использовать функцию setattr:
setattr(Person, 'x', 200) # изменить значение аттрибута x
Таким образом можно и создавать новые атрибуты.

Можно удалять атрибуты: 
del Person.x
delattr(Person, 'name')

Проверка, есть ли у экземпляра определенный атрибут:
    hasattr(экземпляр_класса, имя_аттрибута)

Это все касается атрибутов класса, а не конкретного экземпляра.
 
ПО СУТИ АТРИБУТЫ КЛАССА - ЭТО СТАТИЧЕСКАЯ ПЕРЕМЕННАЯ


####################### АТРИБУТЫ ЭКЗЕМПЛЯРА КЛАССА ################
По умолчанию созданные объекты класса имеют разные адреса в памяти,
то есть код:
a = Person()
b = Person()
Создает два разных объекта.

У экземпляров класса можно посмотреть аттрибуты: 
a.__dict__ # {}
b.__dict__ # {}

При этом можно создать атрибут у конкретного экземпляра:
a.seat = 15 # теперь a.__dict__ = {'seat': 15}


!!!!!!!!! У каждого экземпляра класса есть свое собственное пространство
имен. В нем хранятся атрибуты, которые можно создать, используя оператор=
По умолчанию у экземпляра собственных атрибутов нет.
Код a.set = 15 как раз таки создает атрибут set внутри пространства имен
объекта a. 
Если написать код a.name = 'Denis', то создастся новый атрибут name
внутри экземпляра a.

Если написать далее код a.name, то пайтон сначала будет искать
атрибут в пространстве имен объекта, а если его там нет, то в пространстве
имен класса.
У ВСЕХ ЭКЗЕМПЛЯРОВ СВОЕ ПРОСТРАНСТВО ИМЕН. ПРИ ЭТОМ У КЛАССА ОБЩЕЕ.

По сути у экземпляров есть локальные атрибуты. А атрибуты класса находятся
в глобальной области видимости.




###################### МЕТОДЫ ЭКЗЕМПЛЯРА ######################

 Метод - функция, объявленная внутри класса. Метод класса связан с 
 конкретным экземпляром класса. При вызове метода в качестве аргумента
 автоматически передается этот экземпляр класса, для которого происходит
 вызов.

 Пример метода:

 class Cat:
    name = 'Walt'
    def show_name(instance): # instance - объект, для которого вызов
        print(f"cat name is {instance.name}")


Общепринято вместо instance, т.е вместо переданного экземпляра писать 
self. Это аналог *this из C++.




############### ИНИЦИАЛИЗАИЦИЯ И МЕТОД __init__ ####################
Синтаксис:
def __init__(self):
    # действия
    pass

Работает так: сначала создается объект, а после вызывается метод __init__,
куда в качестве self передается только что созданный объект.

Например: a = Cat() - создается объект, а дальше он передается
в функцию __init__, далее выполняется присваивание.

В __init__ можно передавать параметры, которые можно использовать в 
инициализации. Для этого можно написать:

class Cat:
    def __init__(self, name, age, color):
        self.name = name
        self.age = age
        self.color = color

cat1 = Cat('tom', 13, 'black') - создаем кота и заполняем его атрибуты
при инициализации.

Проверить принадлежность объекта какому-то классу можно так:
isinstance([1, 2, 3], list) # True
isinstance({2, 1, 3}, list) # False





########################## МОНОСОСТОЯНИЕ ##########################

Можно сделать так, чтобы при изменении одного экземпляра класса
менялись сразу все. При добавлении нового атрибута экземпляру он будет
добавляться во всех другие экземпляры. Сделать это можно так:

class Cat:
    __shared_attr = {
        'bread': 'pers',
        'color': 'black'
    }

    def __init__(self):
        self.__dict__ = Cat.__shared_attr

Теперь добавляя новый атрибут, мы будем его добавлять не в __dict__, 
а в __shared_attr, который общий для всех экземпляров.




#################### ИНКАПСУЛЯЦИЯ ##########################

Для создания protected переменных атрибуты следует называть, начиная с 
_. То есть _attribute. При этом доступ не меняется - это всего лишь
соглашение не использовать переменную между разработчиками.

Для создания private перенных используются __. То есть __attribute.
В этом случае вне класса доступа к атрибутам не будет, то есть они будут
доступны только внутри класса. Методы тоже можно называть, начиная с __.
При этом к этим перемнным все же получится получить доступ, 
используя синтаксис: _ИМЯКЛАССА__PRIVATE-ПЕРЕМЕННАЯ




###################### PROPERTY АТРИБУТЫ ###################

Если у нас есть private переменная и геттеры и сеттеры для нее, 
то это будет долго их каждый раз писать. Для этого есть такой выход:

class BankAccount:

    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance
    
    def get_balance(self):
        return self.__balance
    
    def set_balance(self, value):
        self.__balance = value

    balance = property(fget=get_balance, fset=set_balance)

Создадим obj1 = BankAccount('denis', 128). Чтобы получить баланс, 
мы бы писали obj1.get_balance()

Но теперь можно писать так: obj1.balance - на выходе получим 128.

Вместо obj1.set_balance(15) можно писать: obj.balance = 15

При этом все так же будут вызываться геттеры и сеттеры.



Можно удалять атрибут при помощи del:

class BankAccount:

    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance
    
    def get_balance(self):
        return self.__balance
    
    def set_balance(self, value):
        self.__balance = value
    
    def del_balance(self):
        del self.__balance


    balance = property(fget=get_balance, fset=set_balance, fdel=del_balance)

Теперь можно написать: del object.balance, и мы вызовем функцию del_balance и удалим атрибут.


Можно так же написать такой код, он будет делать то же самое:
class BankAccount:

    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance
    
    def get_balance(self):
        return self.__balance
    
    def set_balance(self, value):
        self.__balance = value
    
    def del_balance(self):
        del self.__balance

    balance = property()
    balance = balance.getter(get_balance)
    balance = balance.setter(set_balance)
    balance = balance.deleter(del_balance)

Появляется проблема - двойная функциональность. Можно написать:
a = BankAccount('Denis', 1800)
print(a.get_balance()) # 1800
print(a.balance) # 1800
Теперь можно делать одно и то же двумя разными способами, что плохо. Попробуем сделать так, чтобы можно было делать все только через
переменную balance, без всяких геттеров и сеттеров.
Сделать это можно так:

class BankAccount:

    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance

    def get_balance(self):
        return self.__balance

    def set_balance(self, value):
        self.__balance = value

    def del_balance(self):
        del self.__balance

    get_balance = property(get_balance)


a = BankAccount("Denis", 1800)
print(a.get_balance) #a.get_balance() - такого метода теперь не существует


Заметим, что запись get_balance = property(get_balance) - по сути декорирование. 
Поэтому можно переписать метод таким образом:

class BankAccount:

    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance

    @property
    def get_balance(self):
        return self.__balance

    def set_balance(self, value):
        self.__balance = value

    def del_balance(self):
        del self.__balance


a = BankAccount("Denis", 1800)
print(a.get_balance) #a.get_balance() - такого метода теперь не существует

Чтобы полностью избавиться от геттеров и сеттеров, сделаем так:

class BankAccount:

    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance

    @property
    def balance(self):
        return self.__balance

    @balance.setter
    def balance(self, value):
        self.__balance = value

    @balance.deleter
    def balance(self):
        del self.__balance


Теперь такой код работает без проблем:
a = BankAccount("Denis", 1800)
print(a.balance) # 1800
a.balance = 15
print(a.balance) # 15


Суть в следующем: property атрибуты делают так, что приватные переменные становятся как бы открытыми, 
и синтаксис обращения к ним не меняется. При этом главное отличие от открытых атрибутов в том, что
во время присваивания (либо удаления) значений можно проверять, что имено присваивается, в отличие от открытых 
атрибутов.


////////////////////////////////classmethod и staticmethod

Если определить функцию внутри класса без параметра self, 
то мы не сможем ее вызывать через точку от экземпляра класса.
И наоборот, те которые записаны с self, нельзя вызывать как метод класса.

Вопрос: как создать функцию, которая вызывается и от класса, и от 
экземпляра класса?

Для этого пишем так:

class Test:
    @staticmethod
    def static_hello():
        print("hello")

Функции, вызываемые через object.func_name имеют тип 'method', 
а функции вызываемые через classname.func_name имеют тип 'function'.

Если повесить декоратор @classmethod, то в качестве параметра будет
передаваться имя класса:

class Test:
    def static_hello():
        print("hello")

    @classmethod
    def class_hello(cls):
        print(f"{cls}")


a = Test()
a.class_hello() # <class '__main__.Test'>
Test.class_hello() # <class '__main__.Test'>






/////////////////////(ГЛУБОКО) МАГИЧЕСКИЕ МЕТОДЫ//////////////////////

!!!!!!!!!Метод __repr__:
Отвечает за то, как будет отображаться объект в системе.
Рассмотрим пример:
class Lion:
    def __init__(self, name):
        self.name = name
    

b = Lion('Bob')
print(b) # <__main__.Lion object at 0x0000023a8c10add0>

Объект отображается совсем некрасиво.
Перепишем:

class Lion:
    def __init__(self, name):
        self.name = name
    
    def __repr__(self):
        return f"This is Lion-{self.name}"

b = Lion('Bob')
print(b) # This is Lion-Bob

Этот метод отвечает так же за отображение в консоли.



!!!!!!!!!!!Метод __str__:
class Lion:
    def __init__(self, name):
        self.name = name
    
    def __str__(self):
        return f"This is object lion-{self.name}"

b = Lion('Bob')
print(b) # This is object Lion-Bob

Кроме того, str(b) вернет This is object Lion-Bob.

Получаем, что метод __repr__ нужен для отображения в системе,
__str__ нужен для пользователя.



!!!!!!!!!!!!!Метод __len__:

Этот метод вызывается, когда мы вызываем функцию len(obejct).


!!!!!!!!!!!!!Метод __abs__:
Этот метод вызывается, когда мы вызываем функцию abs(obejct).


!!!!!!!!!!!!Метод __add__:
Реализует оператор+, синтаксис такой:

class BankAccount:
    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
    
    def __add__(self, other):
        if isinstance(other, (int, float)):
            return self.balance + other

По факту код a + 15 делает a.__add__(15). Заметим теперь, что код
15 + a вызывает (15).__add__(a), но в классе int это не реализовано, то
есть будет ошибка. Как этого избежать?


class BankAccount:
    def __init__(self, name, balance):
        self.name = name
        self.balance = balance
    
    def __add__(self, other):
        if isinstance(other, (int, float)):
            return self.balance + other

    def __radd__(other, self):
        return self + other


Остальные методы __mul__ (умножение), __sub__(вычитание), __truediv__
(деление оператором /)


Есть еще операции сравнения: __eq__, __ne__, __le__ и т.д
ВАЖНО!! ДЛЯ НИХ НЕ НУЖНО ПИСАТЬ МЕТОДЫ __req__, __rne__, __rle__ И
прочие.


Синтаксис:
def __eq__(self, other):
    pass

Рассмотрим:
b = Lion('Bob')
print(15 == b)
Сначала тут будет вызываться (15).__eq__(b), но такого метда в int нет,
поэтому будет вызов b.__eq__(15) - а такой уже есть

Допустим у нас написан метод __lt__ и мы пишем:
b = Lion('Bob')
print(b < 15)
print(15 > b) - ошибки не будет, потому что после (15).__gt__(b) 
вызывается b.__lt__(15) - а он как раз таки реализован.
Однако print(15 < b) не сработает, поскольку b.__gt__(15) не реализован.

Если реализован ==, то автоматически будет и !=


__hash__ и __eq__:

Если мы определим метод __eq__, то надо будет определить и метод 
__hash__, поскольку иначе объект станет не хешируемым, а значит
не сможет, например, быть ключом в словаре.
Метод __hash__() вызывается при вызове функции hash()


Метод __bool__:

При создании класса без определения метода __bool__() и __len__()
будет возвращать всегда True. Если у нас будет определен метод __len__(), 
то при использовании метода bool(object) будет вызываться метод len(object),
и если len() вернет число, отличное от нуля, то будет True, иначе False

Если будет определен метод __bool__(), то будет только он вызываться.

__bool__(self) обязательно возвращает объект типа bool, никак иначе,
или будет ошибка. 




///////////////////////// МЕТОД __call__ ////////////////////

По умолчанию экземпляры класса нельзя вызывать, т.е:
a = Counter() # объект класса Counter
a() # получим ошибку, ибо нельзя вызывать.

Можно использовать __call__ так:


from time import perf_counter


class Timer:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        start = perf_counter()
        self.func(*args, **kwargs)
        end = perf_counter()
        print(f"time: {end - start}")


@Timer
def fact(n):
    mult = 1
    for i in range(1, n + 1):
        mult *= i
    return mult


fact(150000) # сработает __call__



/////////////////////// ПОЛИМОРФИЗМ ///////////////////

Полиморфизм - одинаковая работа с разными объектами. Ничего интересного...


//////////////////// МЕТОДЫ __getitem__, __setitem__, __delitem__/////

__getitem__(self, item) - поддержка оператора [], в которые будет 
передаваться item (то есть индекс). 

__setitem__(self, key, value) - присваивает value по индексу, 
те использовать синтаксис self[key] = value

__delitem__(self, key) - использовать синтаксис del self[key]

Пример: 
class Vector:
    def __init__(self, *argc):
        self.values = list(argc)

    def __getitem__(self, item):
        return self.values[item]

    def __setitem__(self, key, value):
        self.values[key] = value

v1 = Vector(5, 6, 7, 1, 2, 3, 4, 6, 7, 1)
v1[2] = 15
print(v1[2]) # 15

/////////////////// МЕТОДЫ __iter__, __next__ /////////////////////

Эти методы позволят нам обходить элементы внутри цикла for.
По умолчанию объекты не итарабельные и их нельзя обойти в цикле for
таким синтаксисом: for i in object: pass

При работе цикла for вместо объекта, который мы обходим, создается
итератор. А дальше к нему применяется на каждой итерации функция next(),
которая возвращает значеине переменной i.

Сделаем наш класс итерабельным так:
1) Определим метод __getitem__(self, key). Тогда в цикле for будет
вызываться этот метод, пока мы не дойдем до конца.
Пример:
class Student:
    def __init__(self, name, surname, marks):
        self.name = name
        self.surname = surname
        self.marks = marks

    def __getitem__(self, key):
        return self.name[key]


s1 = Student("Denis", "Chumak", [12, 231, 32, 1, 3, 21, 3, 2, 1])
for i in s1:
    print(i) # D e n i s

2) Определим метод __iter__. При его наличии python не будет 
обращать внимания на __getitem__.
Пример:
class Student:
    def __init__(self, name, surname, marks):
        self.name = name
        self.surname = surname
        self.marks = marks

    def __getitem__(self, key):
        return self.name[key]

    def __iter__(self):
        return iter(self.surname)


s1 = Student("Denis", "Chumak", [12, 231, 32, 1, 3, 21, 3, 2, 1])
for i in s1:
    print(i) # C h u m a k

Теперь мы сделаем итератор из строки, а далее будет уже вызываться
метод next(), используя в качестве итератора строку. 

Обойдем теперь наш собственный объект так:
class Student:
    def __init__(self, name, surname, marks):
        self.name = name
        self.surname = surname
        self.marks = marks

    def __getitem__(self, key):
        return self.name[key]

    def __iter__(self):
        self.__index = 0
        return self

    def __next__(self):
        if self.__index >= len(self.name):
            del self.__index
            raise StopIteration
        temp = self.__index
        self.__index += 1
        return self.name[temp]


s1 = Student("Denis", "Chumak", [12, 231, 32, 1, 3, 21, 3, 2, 1])
for i in s1:
    print(i)  # D e n i s



//////////////////////// НАСЛЕДОВАНИЕ //////////////////////

Указывать, от какого класса наследуемся можно так:

class Person(Human): # наследуемся от Human
    pass

Чтобы проверить, кто от кого наследуется можно написать: issubclass(Person, Human) - True, наоборот если ввести - будет False.

Мы всегда наследуемся от класса object на самом деле, даже класс Person, хоть мы явно этого не указываем.
При наследовании можно переопределять методы и атрибуты.











/////////////////////// НАСЛЕДОВАНИЕ И super() /////////////////////

Если у нас есть потребность обратиться к родительскому классу, можно
вызвать функцию super().
Пример:
class Human:
    a = 15

    def breathe(self):
        print("breathe human")

    def walk(self):
        print("walk")


class Teacher(Human):

    def breathe(self):
        super().breathe()
        print("breathe teacher")


ob1 = Teacher()
ob1.breathe() # breathe human \n breathe teacher

Пример грамотного использования:
class Human:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname

    def breathe(self):
        print("breathe human")

    def walk(self):
        print("walk")


class Teacher(Human):

    def __init__(self, name, surname, age):
        super().__init__(name, surname)
        self.age = age

    def breathe(self):
        super().breathe()
        print("breathe teacher")


ob1 = Teacher("aadwa", "waww", 12)
print(ob1.name)

ВАЖНО: В метод __init__ родителя автоматически пробрасывается 
тот же self, что и при вызове дочернего класса.



///////////////////// МНОЖЕСТВЕННОЕ НАСЛЕДОВАНИЕ ///////////////////

Синтаксис такой:
class To_build(class1, class2, ...) - наследование от классов class1, ...
Порядок перечисления ВАЖЕН!!!
Метод берется из класса с наимньшим индексом в скобках, считая,
что нумерация начинается слева.

Порядок обхода классов можно посмотреть так:
Person.__mro__ - выведет, в какой последовательности будет происходить
поиск аттрибутов и методов в классах.

Функция super():
Так же зависит от __mro__. Тут аналогично вызывается родитель с 
наименьшим индексом. Чтобы вызвать другого родителя, можно явно написать 
его имя и обратиться через точку.




//////////////////////////// SLOTS ////////////////////////

Нужен для ограничения создания всяких новый атрибутов у экземпляра
класса. __slots__ - атрибут класса, синтаксис такой:

class Point:
    __slots__ = ('x', 'y')
    
    def __init__(self, x, y):
        self.x = x
        self.y = y


res = Point(5, 6)
res.z = 15 # будет ошибка, такой атрибут не получится создать.
del res.y
res.y = 15 # а вот так можно

То есть атрибуты могут быть только те, которые хранятся в __slots__.
Так же теперь класс Point не хранит Point.__dict__ - теперь недоступно.
Это очень полезно, если нам нужно сэкономить память. Кроме того операции
становятся быстрее (создание удаление аттрибутов у экземпляров класса).

Но при этом внутри класса можно создавать атрибуты:
class Point:
    __slots__ = ("x", "y")
    fr = 10

    def __init__(self, x, y):
        self.x = x
        self.y = y


res = Point(5, 6)
print(res.fr) # 10




ОДНАКО ПРИ НАСЛЕДОВАНИИ У ДОЧЕРНЕГО КЛАССА МОЖНО БУДЕТ СОЗДАВАТЬ НОВЫЕ
АТРИБУТЫ, ДАЖЕ ЕСЛИ У РОДИТЕЛЯ БЫЛ __slots__. 
Чтобы убрать это, нужно у дочернего класса тоже прописать __slots__:
class Point:
    __slots__ = ("x", "y")

    def __init__(self, x, y):
        self.x = x
        self.y = y


class ExtPoint(Point):
    __slots__ = "z"

    def __init__(self, x, y, z):
        super().__init__(x, y)
        self.z = z


res = ExtPoint(5, 6, 7)
res.x = 15 # все гуд

    

Причем __slots__ = 'z' расширяет переменную __slots__, а не затирает ее.
То есть теперь в ExtPoint __slots__ = ('x', 'y', 'z')

Если не хотим дополнять переменные в __slots__ в дочернем классе,
можно написать: __slots__ = tuple()